# String 타입 

사용자의 입력을 받아 저장을 해야 하는 경우에는 두번째 문자열 타입인 String을 제공합니다. **이 타입은 힙에 할당**되고 그런고로 컴파일 타임에는 알 수 없는 양의 텍스트를 저장할 수 있습니다.  String으로부터 from() 이라는 함수를 사용하여 String을 아래처럼 만들 수 있습니다. 

```rust
lets = String::from('hello");
```

더블 콜론(::)은 우리가 string_from과 같은 이름을 쓰기 보다는 String 타입 아래의 from 함수를 특정지을 수 있도록 해주는 네임스페이스 연산자입니다


이런 문자열은 변경이 가능합니다. 

```rust
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str()은 해당 스트링 리터럴을 스트링에 붙여줍니다.
    println!("{}", s); // 이 부분이 `hello, world!`를 출력할 겁니다.
}
```




## 메모리와 할당
String은 변할 수 있는데 스트링 리터럴은 안될까요? 차이점은 두 타입이 메모리를 쓰는 방식에 있습니다.


* 스트링 리터럴은 크기를 컴파일 타임에 알 수 있고 텍스트가 최종 실행파일에 하드코딩되어 있습니다. 이렇게 하면 실행시 빠르고 효율적입니다. 
    *  그러나 문자열이 변경되지 안는 것을 전제로 합니다. 
* String 타입은 변경 가능하고 커닐수 있는 텍스트를 지원하기 위해 만들어 졌습니다.
    * 그래서 런타임에 운영체제로부터 메모리가 요청되어야 합니다. 
    * String의 사용이 끝났을 때 운영체제에게 메모리를 반납할 방법이 필요합니다. 



운영체제에게 메모리 요청은 직접합니다. 

```rust
let s = String::from("hello");
```

String::from()을 호ㅗ출하면 필요한 만큼의 메모리를 요청합니다. 
메모리를 반납하는 것은 다른 언어와는 다르게 변수가 소속되어 있는 스코프를 벗어나면 잔동을 반납합니다. 

```rust
{
    let s = String::from("hello"); // s는 여기서부터 유효합니다

    // s를 가지고 뭔가 합니다
}                                  // 이 스코프는 끝났고, s는 더 이상 
                                   // 유효하지 않습니다
```

변수가 스코프 밖으로 벗어나면, 러스트는 우리를 위해 특별한 함수를 호출합니다. 이 함수를 drop이라고 부르고, String의 개발자가 메모리를 반환하도록 하는 코드를 집어넣을 수 있습니다. 러스트는 } 괄호가 닫힐때 자동적으로 drop을 호출합니다.