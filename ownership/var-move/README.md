# 이동(move) 
정수형을 이용한 예제를 보겠습니다. 

```rust
fn main() {
    let x = 5;
    let y = x;
}
```

정수값 5를 X에 묶어 놓고, X의 값의 복사본을 만들어 Y에 묶어 놓습니다.정수값이 결정되어 있는 고정된  크기의 단순한 값이고, 5라는 값들이 스택에 푸쉬됩니다. 



String 버전을 봅시다. 
```rust
let s1 = String::from("hello");
let s2 = s1;
```

String은 문자열의 내용물을 담고 있는 메모리 포인터, 길이, 용량 데이터 그룹을 스택에 저장합니다. 내용물을 담고 있는 것은 힙 메모리에 있습니다. 


s2 에 s1을 대입하면, String 데이터가 복사되는데, 이는 스택에 있는 포인터 , 길이값, 그리고 용량값이 복사된다는 의미입니다. 힙 메모리 상의 데이터는 복사되지 않습니다. 



변수가 스코프 밖으로 벗어날 때, 러스트는 자동적으로 drop함수를 호출하여 해당 변수가 사용하는 힙 메모리를 제거한다고 했습니다. 이것은 문제가 되는데, s2와 s1이 스코프를 벗어나면 둘 다 같은 메모리를 해제하려고 들기 때문입니다. 이는 두 번 해제(double free) 오류라고 알려져 있습니다.  



메모리 안정성을 보장하기 위해서, 러스트는 할당된 메모리를 복사하는 대신, s1이 더 이상 유효하지 않다고 간주합니다. 그러므로 s1이 scope를 벗어날 때 아무것도 해제할 필요가 없습니다. 

아래 예제에서 s1은 유효하지 않기 때문에 println! 에서 오류가 발생합니다. 


```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1);  // 오류 발생
```

러스트는 첫번째 변수를 무효화 시키기도 하기 때문에, 이를 얕은 복사라고 부르는 대신 이동(move)이라 말합니다. 여기서 우리는 s1이 s2로 이동되었다라고 말하는 식으로 위 코드를 읽을 것입니다. 

## Clone
만일 String의 스택 데이터 만이 아니라, 힙 데이터를 깊이 복사하기를 정말 원한다면, clone이라 불리우는 공용 메소드를 사용할 수 있습니다.

```rust
fn main() {
    let s1 = String::from("hello");
    //  힙 데이터를 깊이 복사하기를 정말 원한다면, clone이라 불리우는 공용 메소드를 사용할 수 있습니다
    let s2 = s1.clone();
    
    println!("s1 = {}, s2 = {}", s1, s2);    
}
```
